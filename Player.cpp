#include "Player.h"

//インクルード
#include "Engine/Input.h"
#include "Stage.h"
#include "Engine/Transition.h"
#include "Engine/Image.h"
#include "Engine/Debug.h"
#include "Engine/Camera.h"
#include "AudioManager.h"

//コンストラクタ
Player::Player(GameObject* _parent, string _modelFileName)
	:SolidObject(_parent,_modelFileName,"Player"),
	pState_(nullptr), underRay_(),pStage_(),hGroundModel_(0),acceleration_(0)
{
	//プレイヤーの状態を「立ち状態」で初期化
	ASSIGN(pState_,new PlayerStateManager);
}

//初期化
void Player::ChildInitialize()
{
	//状態の初期化
	ASSIGN(pState_->playerState_, pState_->pStanding_);
	
	//モデルのロード
	ASSIGN(Marker, Model::Load("Models/debugMarker.fbx"));
	ASSIGN(ziro, Model::Load("Models/ziro_move.fbx"));

	Model::SetAnimFrame(ziro, 0, 44, 1);

	//位置の初期化
	transform_.position_.y = 2;

	//初期状態の開始処理
	pState_->Enter(this);

	isMove_ = true;

	pJet = new PolyLine(0.1,10);
	pJet->Load("Effects/Fire.png");

	InitDeadEffect();
	InitRandEffect();

	//pDead = new PolyLine(1,50);
	//pDead->Load("Effects/Tex.png");
	pJet = new PolyLine(0.1, 10);
	pJet->Load("Effects/Fire.png");

	//jump中の処理を行う
	if (isJumpNow_) {transform_.position_.y += 0.1f;
	}

	//重力を加える
	AddGravity(&transform_);

	//ステージとのあたり判定
	StageRayCast();

	//状態ごとの更新
	pState_->Update(this);
}

void Player::ChildUpdate()
{
}

//開放
void Player::ChildRelease()
{
	SAFE_DELETE(pState_);
	//ポリライン解放
	pJet->Release();
}

//描画
void Player::ChildDraw()
{
	//レイのスタート位置を描画
	Transform t;
	t.position_ = RayStartPos;
	t.position_.z -= 0.5f;
	Model::SetTransform(Marker, t);
	Model::Draw(Marker);

	//着地点を描画
	Transform d;
	d.position_ = downLandingPoint;
	Model::SetTransform(Marker, d);
	Model::Draw(Marker);

	Transform up;
	up.position_ = upLandingPoint;
	Model::SetTransform(Marker, up);
	Model::Draw(Marker);

	Transform rg;
	rg.position_ = rightLandingPoint;
	Model::SetTransform(Marker, rg);
	Model::Draw(Marker);

	Transform lf;
	lf.position_ = leftLandingPoint;
	Model::SetTransform(Marker, lf);
	Model::Draw(Marker);

	Transform z;
	z.position_ = transform_.position_;
	z.position_.y -= 0.5;
	z.scale_ = { 0.1f,0.1f,0.1f };
	Model::SetTransform(ziro, z);
	Model::Draw(ziro);

	Direct3D::SetShader(Direct3D::SHADER_UNLIT);
}

void Player::PolyDraw()
{
	if (isJetNow_ == true)
	{
		//ポリラインを描画
		pJet->Draw();
	}
}

void Player::StageRayCast()
{
	//ステージのモデル番号を取得
	ASSIGN(hGroundModel_,dynamic_cast<SolidObject*>((Stage*)FindObject("Stage"))->GetModelHandle());

	//左方向の当たり判定
	{
		RayCastData leftData; {
			leftData.start = transform_.position_;
			RayStartPos = leftData.start;
			XMStoreFloat3(&leftData.dir, XMVectorSet(-1, 0, 0, 0));
			Model::RayCast(hGroundModel_, &leftData);
			leftLandingPoint = leftData.pos;
		}
		if (leftData.dist < (PLAYER_MODEL_SIZE.x / 2)) {
			//めり込み分、位置を戻す
			XMVECTOR length = { -leftData.dist - (PLAYER_MODEL_SIZE.x / 2),0,0 };
			XMStoreFloat3(&transform_.position_, XMLoadFloat3(&transform_.position_) - (XMVectorSet(-1, 0, 0, 0) - length));
		}
	}

	//右方向のあたり判定
	{
		RayCastData rightData; {
			//当たっているかを確認
			rightData.start = transform_.position_;					//発射位置の指定
			XMStoreFloat3(&rightData.dir, XMVectorSet(1, 0, 0, 0));	//発射方向の指定
			Model::RayCast(hGroundModel_, &rightData);				//レイを発射
			rightLandingPoint = rightData.pos;
		}
		//レイの長さが1.0以下だったら...
		if (rightData.dist < (PLAYER_MODEL_SIZE.x / 2)) {
			//めり込み分、位置を戻す
			XMVECTOR length = { rightData.dist + (PLAYER_MODEL_SIZE.x / 2),0,0 };
			XMStoreFloat3(&transform_.position_, XMLoadFloat3(&transform_.position_) - (XMVectorSet(1, 0, 0, 0) - length));
		}
	}

	//上方向のあたり判定
	{
		RayCastData upData; {
			//当たっているか確認
			upData.start = transform_.position_;
			XMStoreFloat3(&upData.dir, XMVectorSet(0, 1, 0, 0));
			Model::RayCast(hGroundModel_, &upData);
			upLandingPoint = upData.pos;
		}
		//レイの長さが1.0以下だったら...
		if (upData.dist < (PLAYER_MODEL_SIZE.y / 2)) {
			//めり込み分、位置を戻す
			XMVECTOR length = { 0, (PLAYER_MODEL_SIZE.y / 2) + upData.dist,0 };
			XMStoreFloat3(&transform_.position_, XMLoadFloat3(&transform_.position_) - (XMVectorSet(0, 1, 0, 0) - length));
			SetAcceleration(2);
		}
	}

	//StandingState,RunningStateときのみ行うからState内で処理を行う
	//下方向のあたり判定
	{
		RayCastData downData; {
			//当たっているか確認
			downData.start = transform_.position_;
			XMStoreFloat3(&downData.dir, XMVectorSet(0, -1, 0, 0));
			Model::RayCast(hGroundModel_,&downData);
			downLandingPoint = downData.pos;
		}
		if (downData.dist < (PLAYER_MODEL_SIZE.y / 2)) {
			//状態を"Standing"に変更
			pState_->ChangeState(pState_->pStanding_, this);
		}
	}
}

void Player::AddGravity(Transform* _transform)
{
	if (!isAddGravity_)return;

	//重力を加える
	_transform->position_ = Transform::Float3Add(_transform->position_, VectorToFloat3((XMVectorSet(0, -1, 0, 0) / 10) * acceleration_));
	acceleration_ += GRAVITY_ADDITION;
}

void Player::InitDeadEffect()
{
	DeadEffectData.textureFileName = "Effects/cloudA.png";
	DeadEffectData.positionRnd = XMFLOAT3(0.1, 0, 0.1);
	DeadEffectData.delay = 0;
	DeadEffectData.number = 1;
	DeadEffectData.lifeTime = 60;
	DeadEffectData.gravity = -0.002f;
	DeadEffectData.direction = XMFLOAT3(0, 1, 0);
	DeadEffectData.directionRnd = XMFLOAT3(0, 0, 0);
	DeadEffectData.speed = 0.01f;
	DeadEffectData.speedRnd = 0.0;
	DeadEffectData.size = XMFLOAT2(1, 10);
	DeadEffectData.sizeRnd = XMFLOAT2(0.4, 0.4);
	DeadEffectData.scale = XMFLOAT2(1.01, 1.01);
	DeadEffectData.color = XMFLOAT4(0, 0, 1, 1);
	DeadEffectData.deltaColor = XMFLOAT4(0, -0.03, 0, -0.02);
}

void Player::InitRandEffect()
{
	RandEffectData_.textureFileName = "Effects/RandSmoke2.png";
	RandEffectData_.position = XMFLOAT3(transform_.position_.x, transform_.position_.y - 0.2, 0);
	RandEffectData_.positionRnd = XMFLOAT3(0.1, 0, 0.1);
	RandEffectData_.delay = 0;
	RandEffectData_.number = 1;
	RandEffectData_.lifeTime = 40;
	RandEffectData_.speed = 0.01f;
	RandEffectData_.speedRnd = 0.0;
	RandEffectData_.size = XMFLOAT2(1, 0.5);
	RandEffectData_.scale = XMFLOAT2(1.01, 1.01);
	RandEffectData_.color = XMFLOAT4(1, 1, 1, 1);
	RandEffectData_.deltaColor = XMFLOAT4(0, 0, 0, -0.1);
}

EmitterData Player::GetDeadEData()
{
	return DeadEffectData;
}

EmitterData Player::GetRandEData()
{
	return RandEffectData_;
}

PolyLine Player::GetJettPData()
{
	return *pJet;
}

void Player::SetIsJetNow(bool _jet)
{
	isJetNow_ = _jet;
}

void Player::AllStageRayCast()
{
	//ステージのモデル番号リストを取得
	vector<int> stageList = dynamic_cast<Stage*>((Stage*)FindObject("Stage"))->GetAllStageModelHandle();

	//すべてのモデルとあたり判定を行う
	for (vector<int>::iterator it = stageList.begin(); it != stageList.end(); ++it) {

		//左方向の当たり判定
		{
			RayCastData leftData; {
				leftData.start = transform_.position_;
				RayStartPos = leftData.start;
				XMStoreFloat3(&leftData.dir, XMVectorSet(-1, 0, 0, 0));
				Model::RayCast(*it, &leftData);
				leftLandingPoint = leftData.pos;
			}
			if (leftData.dist < (PLAYER_MODEL_SIZE.x / 2)) {
				//めり込み分、位置を戻す
				XMVECTOR length = { -leftData.dist - (PLAYER_MODEL_SIZE.x / 2),0,0 };
				XMStoreFloat3(&transform_.position_, XMLoadFloat3(&transform_.position_) - (XMVectorSet(-1, 0, 0, 0) - length));
			}
		}

		//StandingState,RunningStateときのみ行うからState内で処理を行う
		//下方向のあたり判定
		{
			RayCastData downData; {
				//当たっているか確認
				downData.start = transform_.position_;
				XMStoreFloat3(&downData.dir, XMVectorSet(0, -1, 0, 0));
				Model::RayCast(hGroundModel_, &downData);
				downLandingPoint = downData.pos;
			}
			if (downData.dist < (PLAYER_MODEL_SIZE.y / 2)) {
				//状態を"Standing"に変更
				pState_->ChangeState(pState_->pStanding_, this);

				//jump状態を終了
				isJumpNow_ = false;
			}
			else
				isAddGravity_ = true;

		}
	}
}
